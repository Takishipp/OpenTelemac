C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!>  @brief       ALLOCATES A BIEF_MESH MESH STRUCTURE.

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!>  @par Use(s)
!><br>BIEF
!>  @par Variable(s)
!>  <br><table>
!>     <tr><th> Argument(s)
!>    </th><td> CFG, EQUA, I3, I4, IELM, MESH, NELMAX, NFIC, NOM, NPLAN, NPMAX, NPTFRX, SPHERI
!>   </td></tr>
!>     <tr><th> Use(s)
!>    </th><td>
!> BIEF_DEF :<br>
!> @link BIEF_DEF::NBMAXDSHARE NBMAXDSHARE@endlink, 
!> @link BIEF_DEF::NBMAXNSHARE NBMAXNSHARE@endlink, 
!> @link BIEF_DEF::NCSIZE NCSIZE@endlink, 
!> @link BIEF_DEF::NPTIR NPTIR@endlink
!>   </td></tr>
!>     <tr><th> Common(s)
!>    </th><td>
!> INFO : LNG, LU
!>   </td></tr>
!>     <tr><th> Internal(s)
!>    </th><td> D, ERR, I, IB, IELB0, IELB0V, IELB1, IELB1V, IELEM, IELM0, IELM1, IKLES, IPOBO, MXELVS, MXPTVS, NDP, NELEM, NNELEB, NNELMAX, NNPLAN, NNPMAX, NNPTFRX, NPOIN, NPOIN_MAX, NPTFR, NSEG, NSEGBOR, P_ISUM, STOCFG
!>   </td></tr>
!>     <tr><th> Alias(es)
!>    </th><td> EX_ALMESH
!>   </td></tr>
!>     </table>

!>  @par Call(s)
!>  <br><table>
!>     <tr><th> Known(s)
!>    </th><td> ALLMAT(), ALLVEC(), CPIKLE2(), CPIKLE3(), CPSTVC(), DIMENS(), IELBOR(), ININDS(), MXPTEL(), NBFEL(), NBMPTS(), NBPEL(), NBPTS(), NBSEG(), NBSEGEL(), OV_2(), PLANTE(), READGEO1(), READGEO2(), READGEO3(), SEGBOR()
!>   </td></tr>
!>     </table>

!>  @par Called by
!><br>POINT_ARTEMIS(), POINT_SISYPHE(), POINT_TELEMAC2D(), POINT_TELEMAC3D(), POINT_TOMAWAC()

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!>  @par Development history
!>   <br><table>
!> <tr><th> Release </th><th> Date </th><th> Author </th><th> Notes </th></tr>
!>  <tr><td><center> 6.0                                       </center>
!>    </td><td> 21/08/2010
!>    </td><td> N.DURAND (HRW), S.E.BOURBAN (HRW)
!>    </td><td> Creation of DOXYGEN tags for automated documentation and cross-referencing of the FORTRAN sources
!>   </td></tr>
!>  <tr><td><center> 6.0                                       </center>
!>    </td><td> 13/07/2010
!>    </td><td> N.DURAND (HRW), S.E.BOURBAN (HRW)
!>    </td><td> Translation of French comments within the FORTRAN sources into English comments
!>   </td></tr>
!>      <tr>
!>      <td><center> 6.0                                       </center>
!> </td><td> 05/02/2010
!> </td><td> J-M HERVOUET (LNHE) 01 30 87 80 18
!> </td><td> EDGE-BASED STUCTURES ALWAYS ALLOCATED
!> </td></tr>
!>  </table>

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!>  @par Details of primary variable(s)
!>  <br><table>
!>
!>     <tr><th>Name(s)</th><th>(in-out)</th><th>Description</th></tr>
!>          <tr><td>CFG(1)
!></td><td>--></td><td>OPTION DE STOCKAGE  1 : EBE CLASSIQUE
!>                  2 : EBE ASSEMBLE
!>    </td></tr>
!>          <tr><td>CFG(2)
!></td><td>--></td><td>MATRICE X VECTEUR   1 : EBE CLASSIQUE
!>                  2 : FRONTAL
!>    </td></tr>
!>          <tr><td>EQUA
!></td><td>--></td><td>NAME IN 20 CHARACTERS TO ENABLE DIFFERENT
!>                  OPTIONS. OPTIONS ARE:
!>                  "SAINT-VENANT EF"
!>                  "SAINT-VENANT VF"
!>                  "BOUSSINESQ"
!>    </td></tr>
!>          <tr><td>I3
!></td><td>---</td><td>
!>    </td></tr>
!>          <tr><td>I4
!></td><td>---</td><td>
!>    </td></tr>
!>          <tr><td>IELM
!></td><td>--></td><td>ELEMENT QUI CONTIENT LE PLUS GRAND NOMBRE
!>                  DE POINTS QUI SERA UTILISE.
!>    </td></tr>
!>          <tr><td>MESH
!></td><td>--></td><td>STRUCTURE A ALLOUER
!>    </td></tr>
!>          <tr><td>MXELVS
!></td><td>--></td><td>NOMBRE MAXIMUM D'ELEMENTS VOISINS D'UN POINT.
!>    </td></tr>
!>          <tr><td>MXPTVS
!></td><td>--></td><td>NOMBRE MAXIMUM DE POINTS VOISINS D'UN POINT.
!>    </td></tr>
!>          <tr><td>NELMAX
!></td><td>---</td><td>
!>    </td></tr>
!>          <tr><td>NFIC
!></td><td>---</td><td>
!>    </td></tr>
!>          <tr><td>NOM
!></td><td>--></td><td>NAME OF THE MESH
!>    </td></tr>
!>          <tr><td>NPLAN
!></td><td>---</td><td>
!>    </td></tr>
!>          <tr><td>NPMAX
!></td><td>---</td><td>
!>    </td></tr>
!>          <tr><td>NPTFRX
!></td><td>---</td><td>
!>    </td></tr>
!>          <tr><td>SPHERI
!></td><td>--></td><td>LOGIQUE, SI OUI : COORDONNEES SPHERIQUES
!>    </td></tr>
!>     </table>
C
C#######################################################################
C
                        SUBROUTINE ALMESH
     &(MESH,NOM,IELM,SPHERI,CFG,NFIC,EQUA,NPLAN,NPMAX,NPTFRX,NELMAX,
     & I3,I4)
C
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C| CFG(1)         |-->| OPTION DE STOCKAGE  1 : EBE CLASSIQUE
C|                |   | 2 : EBE ASSEMBLE
C| CFG(2)         |-->| MATRICE X VECTEUR   1 : EBE CLASSIQUE
C|                |   | 2 : FRONTAL
C| EQUA           |-->| NAME IN 20 CHARACTERS TO ENABLE DIFFERENT
C|                |   | OPTIONS. OPTIONS ARE:
C|                |   | "SAINT-VENANT EF"
C|                |   | "SAINT-VENANT VF"
C|                |   | "BOUSSINESQ"
C| I3             |---| 
C| I4             |---| 
C| IELM           |-->| ELEMENT QUI CONTIENT LE PLUS GRAND NOMBRE
C|                |   | DE POINTS QUI SERA UTILISE.
C| MESH           |-->| STRUCTURE A ALLOUER
C| MXELVS         |-->| NOMBRE MAXIMUM D'ELEMENTS VOISINS D'UN POINT.
C| MXPTVS         |-->| NOMBRE MAXIMUM DE POINTS VOISINS D'UN POINT.
C| NELMAX         |---| 
C| NFIC           |---| 
C| NOM            |-->| NAME OF THE MESH
C| NPLAN          |---| 
C| NPMAX          |---| 
C| NPTFRX         |---| 
C| SPHERI         |-->| LOGIQUE, SI OUI : COORDONNEES SPHERIQUES
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C
      USE BIEF, EX_ALMESH => ALMESH
C
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      TYPE(BIEF_MESH)  , INTENT(INOUT)           :: MESH
      INTEGER          , INTENT(IN)              :: IELM
      INTEGER          , INTENT(IN)              :: NFIC
      LOGICAL          , INTENT(IN)              :: SPHERI
      CHARACTER(LEN=6) , INTENT(IN)              :: NOM
      CHARACTER(LEN=20), INTENT(IN)              :: EQUA
      INTEGER          , INTENT(INOUT)           :: CFG(2)
      INTEGER          , INTENT(IN),    OPTIONAL :: NPLAN
      INTEGER          , INTENT(IN),    OPTIONAL :: NPMAX
      INTEGER          , INTENT(IN),    OPTIONAL :: NPTFRX
      INTEGER          , INTENT(IN),    OPTIONAL :: NELMAX
      INTEGER          , INTENT(INOUT), OPTIONAL :: I3,I4
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      INTEGER D,IELM0,IELM1,STOCFG,IELB0,IELB1,NSEG,NNPMAX
      INTEGER NNPTFRX,NNELEB,ERR,NNELMAX,NNPLAN,NPOIN,NPTFR,NELEM
      INTEGER MXPTVS,MXELVS,NDP,IB(10),IELEM,NSEGBOR
C
C     TEMPORARY CONNECTIVITY TABLE
C
      INTEGER, ALLOCATABLE :: IKLES(:)
C
C     TEMPORARY TABLE TO NUMBER THE BOUNDARY NODES
C
      INTEGER, ALLOCATABLE :: IPOBO(:)
!
      INTEGER IELB0V,IELB1V
C
      INTEGER I
C
C     FH-JAJ
C     FOR SIZE OF KNOGL
      INTEGER :: NPOIN_MAX
      INTEGER, EXTERNAL :: P_ISUM
C
C-----------------------------------------------------------------------
C
C     FIRST READS THE GEOMETRY FILE TO GET NPOIN,.. IB
C
      MESH%NAME = NOM
C
CCCCCCCCCCCCCCCCCCCCC
C 3D : ALSO GETS NNELEB
CCCCCCCCCCCCCCCCCCCCC
C
C     IN PARALLEL MODE, THIS IS WHERE NPTIR IS READ
C
      CALL READGEO1(NPOIN,NELEM,NPTFR,NDP,IB,NFIC,NNELEB)
C
      IF(PRESENT(I3)) I3=IB(3)
      IF(PRESENT(I4)) I4=IB(4)
C
C ALLOCATES THE TEMPORARY CONNECTIVITY TABLE
C
      ALLOCATE(IKLES(NELEM*NDP),STAT=ERR)
C
      IF(ERR.NE.0) THEN
        IF(LNG.EQ.1) THEN
          WRITE(LU,*) 'ALMESH : ALLOCATION DE IKLES DEFECTUEUSE'
        ENDIF
        IF(LNG.EQ.2) THEN
          WRITE(LU,*) 'ALMESH : WRONG ALLOCATION OF IKLES'
        ENDIF
        STOP
      ENDIF
C
C ALLOCATES THE TEMPORARY TABLE FOR THE BOUNDARY NODES
C
      ALLOCATE(IPOBO(NPOIN),STAT=ERR)
C
      IF(ERR.NE.0) THEN
        IF(LNG.EQ.1) THEN
          WRITE(LU,*) 'ALMESH : ALLOCATION DE IPOBO DEFECTUEUSE'
        ENDIF
        IF(LNG.EQ.2) THEN
          WRITE(LU,*) 'ALMESH : WRONG ALLOCATION OF IPOBO'
        ENDIF
        STOP
      ENDIF
C
CCCCCCCCCCCCCCCCCCCCCCC
C READGEO2 WILL ALSO TAKE IPOBO (ARRAY READ IN THIS SUBROUTINE) IN
C ARGUMENT. IT IS CURRENTLY ONLY USED INSIDE THIS SUBROUTINE, EXCEPT
C IN THIS CASE, WHERE IT WILL BE REQUIRED LATER.
C SINCE IT IS IN THE GEO FILE, WHY NOT USE IT?
C ARGUMENTS MXPTVS AND MXELVS WILL BE DELETED AND TRANSFERED IN UPCOMING
C CALL TO MXPTEL. THESE NUMBERS ARE NOT RELATED TO THE READING OF THE
C GEO FILE.
CCCCCCCCCCCCCCCCCCCCCCC
C
C READS IPOBO
C
      CALL READGEO2(NPOIN,NELEM,NPTFR,NDP,IKLES,IPOBO,IB,NFIC)
C
CCCCCCCCCCCCCCCCCCCCCCC
C THIS IS WHERE CALL TO MXPTEL WILL NOW BE (INSTEAD OF WITHIN READGEO2)
C MXPTVS AND MXELVS WILL BE COMPUTED DEPENDING ON THE TYPE OF ELEMENT
CCCCCCCCCCCCCCCCCCCCCCC
C
C CALCULATES THE MAXIMUM NUMBER OF ELEMENTS AROUND A NODE MXELVS
C AND THE MAXIMUM NUMBER OF SURROUNDING NODES, MXPTVS
C
      CALL MXPTEL(MXPTVS,MXELVS,IKLES,IELM,
     &              NPOIN,NELEM,NDP,IPOBO,.TRUE.)
C
      DEALLOCATE(IPOBO)
C
C
C-----------------------------------------------------------------------
C
C
C     INITIALISES COMMONS DIMS AND NODES
C
      IF(PRESENT(NPMAX)) THEN
        NNPMAX = NPMAX
      ELSE
        NNPMAX = NPOIN
      ENDIF
      IF(PRESENT(NPTFRX)) THEN
        NNPTFRX = NPTFRX
      ELSE
        NNPTFRX = NPTFR
      ENDIF
      IF(PRESENT(NELMAX)) THEN
        NNELMAX = NELMAX
      ELSE
        NNELMAX = NELEM
      ENDIF
      IF(PRESENT(NPLAN)) THEN
        NNPLAN = NPLAN
      ELSE
        NNPLAN = 1
      ENDIF
C
      IF(NCSIZE.GT.1) THEN
C
C     IN PARALLEL MODE NSEGBOR (COMPUTED IN SEGBOR) IS NOT NPTFR
C
        CALL SEGBOR(NSEGBOR,IKLES,NELEM,NELMAX,NPOIN)
      ELSE
        NSEGBOR=NPTFR
      ENDIF
C
C     IN CALL ININDS, ALL VALUES ARE 2D VALUES
C     ONLY NNPLAN TELLS IF IT'S 2D OR 3D
C
CC 3D TETRAHEDRONS MESH:
CC ADD THE OPTIONAL ARGUMENT NNELEB
C
      CALL ININDS(NPOIN,NPTFR,NELEM,NNPMAX,NNPTFRX,NNELMAX,NNPLAN,
     &            NSEGBOR,NNELEB)
C
C     P0 AND P1 ELEMENTS
C
      IELM0  = 10*(IELM/10)
      IELM1  = IELM0 + 1
      D      = DIMENS(IELM0)
C
C BOUNDARY ELEMENTS (AT THE SURFACE AND AT THE BOTTOM FOR PRISMS)
C
      IELB0  = IELBOR(IELM0,1)
      IELB1  = IELBOR(IELM1,1)
C
C LATERAL BOUNDARY ELEMENTS (DIFFERENT FOR PRISMS)
C
      IELB0V = IELBOR(IELM0,2)
      IELB1V = IELBOR(IELM1,2)
C
C-----------------------------------------------------------------------
C
C  ALLOCATES THE ARRAYS OF REALS
C
C     COORDINATES BY ELEMENTS: XEL, YEL, ZEL
C
      ALLOCATE(MESH%XEL)
      ALLOCATE(MESH%YEL)
      ALLOCATE(MESH%ZEL)
C
      CALL ALLVEC(1,MESH%XEL,'XEL   ',IELM0,NBPEL(IELM1),1)
      CALL ALLVEC(1,MESH%YEL,'YEL   ',IELM0,NBPEL(IELM1),1)
C
      IF(D.GE.3) THEN
        CALL ALLVEC(1,MESH%ZEL,'ZEL   ',IELM0,NBPEL(IELM1),1)
      ELSE
        CALL ALLVEC(1,MESH%ZEL,'ZEL   ',    0,           1,0)
      ENDIF
C
C     SURFACES OF THE ELEMENTS: SURFAC
C     JAJ CAN BE USED FOR ELEMENT VOLUMES...
C
      ALLOCATE(MESH%SURFAC)
      CALL ALLVEC(1,MESH%SURFAC,'SURFAC',IELM0,1,1)
C
C     1/DET : SURDET ! NOT USED IN 3D, WHY?
C
      ALLOCATE(MESH%SURDET)
      CALL ALLVEC(1,MESH%SURDET,'SURDET',IELM0,1,1)
C
C     LENGTHS OF THE SEGMENTS: LGSEG
C     CAN BE USED (IN THEORY) FOR LATERAL SURFACES IN 3D,
C     BUT THEN IELB0V INSTEAD OF IELB0! (2D CASE NOT AFFECTED)
C
      ALLOCATE(MESH%LGSEG)
      CALL ALLVEC(1,MESH%LGSEG,'LGSEG ',IELB0V,1,1)
C
C     NORMALS TO THE SEGMENTS: XSGBOR, YSGBOR, ZSGBOR
C CAN BE (IN THEORY) USED FOR "NON-SIGMA" MESH FOR LATERAL NORMAL VECTORS
C PER LATERAL BOUNDARY ELEMENT, BUT THEN IELB0V INSTEAD OF IELB0!
C 2D CASE NOT AFFECTED
C
      ALLOCATE(MESH%XSGBOR)
      ALLOCATE(MESH%YSGBOR)
      ALLOCATE(MESH%ZSGBOR)
C     SEE NORMAB FOR MEANING OF 4 DIMENSIONS
      CALL ALLVEC(1,MESH%XSGBOR,'XSGBOR',IELB0V,4,1)
      CALL ALLVEC(1,MESH%YSGBOR,'YSGBOR',IELB0V,4,1)
      IF(D.GE.3) THEN
        CALL ALLVEC(1,MESH%ZSGBOR,'ZSGBOR',IELB0V,4,1)
      ELSE
        CALL ALLVEC(1,MESH%ZSGBOR,'ZSGBOR',    0,4,0)
      ENDIF
C
C     NORMALS AT THE NODES: XNEBOR, YNEBOR, ZNEBOR
!
C IN 3D THEY ARE NORMAL VECTORS AT THE BOTTOM
C SO THAT IELB1 REMAINS
!
      ALLOCATE(MESH%XNEBOR)
      ALLOCATE(MESH%YNEBOR)
      ALLOCATE(MESH%ZNEBOR)
!
      CALL ALLVEC(1,MESH%XNEBOR,'XNEBOR',IELB1,2,1)
      CALL ALLVEC(1,MESH%YNEBOR,'YNEBOR',IELB1,2,1)
!
      IF(D.GE.3) THEN !JAJ NOT USED, ACTUALLY
        CALL ALLVEC(1,MESH%ZNEBOR,'ZNEBOR',IELB1,2,1)
      ELSE
        CALL ALLVEC(1,MESH%ZNEBOR,'ZNEBOR',    0,2,0)
      ENDIF
C
C     COORDINATES BY POINTS: X, Y AND Z
C
      ALLOCATE(MESH%X)
      ALLOCATE(MESH%Y)
      ALLOCATE(MESH%Z)
      CALL ALLVEC(1,MESH%X,'X     ',IELM1,1,1)
      CALL ALLVEC(1,MESH%Y,'Y     ',IELM1,1,1)
      IF(D.GE.3) THEN
        CALL ALLVEC(1,MESH%Z,'Z     ',IELM1,1,1)
      ELSE
        CALL ALLVEC(1,MESH%Z,'Z     ',    0,1,0)
      ENDIF
C
C     COS AND SIN OF THE LATITUDE
C     WITH IELM (EXAMPLE : VELOCITY IN CORIOLIS)
C     COSLAT AND SINLAT ARE WORKING ARRAYS, TO WHICH
C     THE STRUCTURE OF X IS GIVEN TO BEGIN WITH.
C     THEY CAN BE EXTENDED TO ELEMENT IELM AT A LATER DATE.
C
      ALLOCATE(MESH%COSLAT)
      ALLOCATE(MESH%SINLAT)
      IF(SPHERI) THEN ! DIFFERENT COMPARED TO V2.3
        CALL ALLVEC(1,MESH%COSLAT,'COSLAT',IELM,1,2)
        CALL ALLVEC(1,MESH%SINLAT,'SINLAT',IELM,1,2)
        CALL CPSTVC(MESH%X,MESH%COSLAT)
        CALL CPSTVC(MESH%X,MESH%SINLAT)
      ELSE
        CALL ALLVEC(1,MESH%COSLAT,'COSLAT',   0,1,0)
        CALL ALLVEC(1,MESH%SINLAT,'SINLAT',   0,1,0)
      ENDIF
C
C     DISTANCES TO BOUNDARIES : DISBOR
C
      ALLOCATE(MESH%DISBOR)
      CALL ALLVEC(1,MESH%DISBOR,'DISBOR',IELB0,1,1)
C
C     WORKING MATRIX (INTERNAL TO BIEF), WITH CLASSICAL STORAGE
C
      STOCFG = CFG(1)
      CFG(1) = 1
      ALLOCATE(MESH%M)
      CALL ALLMAT(MESH%M,'M     ',IELM,IELM,CFG,'Q','Q')
      CFG(1) = STOCFG
C
C     WORKING MATRIX BY SEGMENT
C
      ALLOCATE(MESH%MSEG)
C     FROM 5.9 ON, ALWAYS DONE IN 2D (IELM=11,12,13 OR 14)
      IF(CFG(1).EQ.3.OR.10*(IELM/10).EQ.10) THEN
        CALL ALLMAT(MESH%MSEG,'MSEG  ',IELM,IELM,CFG,'Q','Q')
      ELSE
        CALL ALLMAT(MESH%MSEG,'MSEG  ',IELM,IELM,CFG,'0','0')
      ENDIF
C
C     WORKING ARRAY FOR A NOT ASSEMBLED VECTOR
C
      ALLOCATE(MESH%W)
      CALL ALLVEC(1,MESH%W,'W     ',IELM0,NBPEL(IELM),2)
C
C     WORKING ARRAY FOR A NORMAL VECTOR
C
      ALLOCATE(MESH%T)
      CALL ALLVEC(1,MESH%T,'T     ',IELM,1,2)
C
C     VNOIN: ARRAY WITH NORMALS VNOIN FOR FINITE VOLUMES
C     CMI: COORDINATES OF THE MIDDLE OF THE SEGMENTS (KINETIC SCHEMES)
C     DTHAUT:
C     DPX,DPY: GRADIENTS OF THE BASE FUNCTIONS
C
      ALLOCATE(MESH%VNOIN)
      ALLOCATE(MESH%CMI)
      ALLOCATE(MESH%AIRST)
      ALLOCATE(MESH%DTHAUT)
      ALLOCATE(MESH%DPX)
      ALLOCATE(MESH%DPY)
      IF(EQUA(1:15).EQ.'SAINT-VENANT VF') THEN
        NSEG=NBSEG(IELM1)
        CALL ALLVEC(1,MESH%VNOIN ,'VNOIN ',3*NSEG,1,0)
        CALL ALLVEC(1,MESH%CMI   ,'CMI   ',2*NSEG,1,0)
        CALL ALLVEC(1,MESH%AIRST ,'AIRST ',2*NSEG,1,0)
        CALL ALLVEC(1,MESH%DTHAUT,'DTHAUT',IELM1,1,2)
        CALL ALLVEC(1,MESH%DPX   ,'DPX   ',IELM0,3,2)
        CALL ALLVEC(1,MESH%DPY   ,'DPY   ',IELM0,3,2)
      ELSE
        CALL ALLVEC(1,MESH%VNOIN ,'VNOIN ',     0,1,0)
        CALL ALLVEC(1,MESH%CMI   ,'CMI   ',     0,1,0)
        CALL ALLVEC(1,MESH%AIRST ,'AIRST ',     0,1,0)
        CALL ALLVEC(1,MESH%DTHAUT,'DTHAUT',     0,1,0)
        CALL ALLVEC(1,MESH%DPX   ,'DPX   ',     0,1,0)
        CALL ALLVEC(1,MESH%DPY   ,'DPY   ',     0,1,0)
      ENDIF
C
C     FOR PARALLEL MODE
C
      ALLOCATE(MESH%XSEG)
      ALLOCATE(MESH%YSEG)
      ALLOCATE(MESH%FAC)
C     THERE ALLVEC IS IN PARINI
      ALLOCATE(MESH%BUF_SEND)
      ALLOCATE(MESH%BUF_RECV)
C
      IF(NCSIZE.GT.1) THEN
C
C       XSEG
        CALL ALLVEC(1,MESH%XSEG,'XSEG  ',IELBOR(IELM1,2),1,2)
C       YSEG
        CALL ALLVEC(1,MESH%YSEG,'YSEG  ',IELBOR(IELM1,2),1,2)
C       FAC
        CALL ALLVEC(1,MESH%FAC,'FAC   ',IELM ,1,2)
C
      ELSE
        CALL ALLVEC(1,MESH%XSEG  ,'XSEG  ',0,1,0)
        CALL ALLVEC(1,MESH%YSEG  ,'YSEG  ',0,1,0)
        CALL ALLVEC(1,MESH%FAC   ,'FAC   ',0,1,0)
      ENDIF
C
C-----------------------------------------------------------------------
C
C     1) INTEGER VALUES (ALLOCATE BECAUSE THEY ARE POINTERS)
C
      ALLOCATE(MESH%NELEM)
      MESH%NELEM  = NBPTS(IELM0)
      ALLOCATE(MESH%NELMAX)
      MESH%NELMAX = NBMPTS(IELM0)
!
!
C I DO USE MESH%NPTFR FOR THE NUMBER OF LATERAL BOUNDARY NODES
C IELBOR(IELM0,1) CHANGED TO IELBOR(IELM1,1)
C THE PROBLEM IS, THAT FOR 3D (IELM=41):
C NBPTS(IELBOR(IELM0,1)) CONTAINS THE NUMBER OF HORIZONTAL BOUNDARY ELEMENTS
C NBPTS(IELBOR(IELM0,2)) CONTAINS THE NUMBER OF VERTICAL BOUNDARY ELEMENTS
C NBPTS(IELBOR(IELM1,1)) CONTAINS THE NUMBER OF HORIZONTAL BOUNDARY NODES
C NBPTS(IELBOR(IELM1,2)) CONTAINS THE NUMBER OF VERTICAL BOUNDARY NODES
!
C FUNNY, BUT THE 2D CASE IS NOT AFFECTED, BECAUSE THE NUMBER OF BOUNDARY
C SEGMENTS IS EQUAL TO THE NUMBER OF BOUNDARY NODES.
!
      ALLOCATE(MESH%NPTFR)
      MESH%NPTFR  = NBPTS(IELBOR(IELM1,2))
      ALLOCATE(MESH%NPTFRX)
      MESH%NPTFRX = NBMPTS(IELBOR(IELM1,2))
!
C NUMBER OF LATERAL BOUNDARY ELEMENTS
!
      ALLOCATE(MESH%NELEB)
      ALLOCATE(MESH%NELEBX)
CC 3D MESH
      IF(IELM.EQ.31) THEN
        MESH%NELEB   = NNELEB
        MESH%NELEBX  = NNELEB
      ELSEIF(IELM.EQ.11.OR.IELM.EQ.12.OR.IELM.EQ.13.OR.IELM.EQ.14) THEN
        MESH%NELEB   = NPTFR
        MESH%NELEBX  = NNPTFRX
      ELSEIF(IELM.EQ.41) THEN
        MESH%NELEB   = NPTFR*(NNPLAN-1)
        MESH%NELEBX  = NNPTFRX*(NNPLAN-1)
      ELSEIF(IELM.EQ.51) THEN
        MESH%NELEB   = 2*NPTFR*(NNPLAN-1)
        MESH%NELEBX  = 2*NNPTFRX*(NNPLAN-1)
      ELSE
        WRITE(LU,*) 'ALMESH, UNEXPECTED ELEMENT FOR NELEB:',IELM
        CALL PLANTE(1)
        STOP
      ENDIF
!
      ALLOCATE(MESH%DIM)
      MESH%DIM    = DIMENS(IELM0)
      ALLOCATE(MESH%TYPELM)
      MESH%TYPELM = IELM0
      ALLOCATE(MESH%NPOIN)
      MESH%NPOIN  = NBPTS(IELM1)
      ALLOCATE(MESH%NPMAX)
      MESH%NPMAX  = NBMPTS(IELM1)
      ALLOCATE(MESH%MXPTVS)
      MESH%MXPTVS = MXPTVS
      ALLOCATE(MESH%MXELVS)
      MESH%MXELVS = MXELVS
C     LV WILL BE RECOMPUTED LATER
      ALLOCATE(MESH%LV)
      MESH%LV     = 1
      ALLOCATE(MESH%NSEG)
      MESH%NSEG = NBSEG(IELM1)
C
C     2) ARRAYS OF INTEGERS
C
C     ALLOCATES IKLE AND KLEI (SAME SIZE, 2 INVERTED DIMENSIONS)
C
      ALLOCATE(MESH%IKLE)
      CALL ALLVEC(2,MESH%IKLE,'IKLE  ',IELM0,NBPEL(IELM),1)
      ALLOCATE(MESH%KLEI)
      CALL ALLVEC(2,MESH%KLEI,'KLEI  ',IELM0,NBPEL(IELM),1)
C
C     IFABOR
C
      ALLOCATE(MESH%IFABOR)
      CALL ALLVEC(2,MESH%IFABOR,'IFABOR',IELM0,NBFEL(IELM),1)
C
C     NELBOR
C
C NELBOR & NULONE
C IT IS NOW CHANGED TO VERTICAL BOUNDARY ELEMENT...
C 2D NOT AFFECTED, 3D USAGE NELBO3(NPTFR,NETAGE) - NO. OF LAT. BD. ELEMENTS
!
      ALLOCATE(MESH%NELBOR)
      CALL ALLVEC(2,MESH%NELBOR,'NELBOR',IELBOR(IELM0,2),1,1)
!
C     NULONE
!
!
C EXTRAORDINARILY STRANGE GEOMETRICALLY
C IN 2D NUMBER OF BOUNDARY NODES IS EQUAL TO THE NUMBER OF BOUNDARY
C ELEMENTS... IN 3D IT IS NOT THE CASE!
C NULONE 3D IS USED INTERNALLY AS: NULONE(NPTFR,NETAGE,4)
C "ASSOCIATES THE LOCAL BOUNDARY NUMBERING TO LOCAL 3D NUMBERING"
!
      ALLOCATE(MESH%NULONE)
!
      CALL ALLVEC(2,MESH%NULONE,'NULONE',
     &            IELBOR(IELM0,2),NBPEL(IELBOR(IELM,2)),1)
!
C!! NOTE : FOR THE TETRAHEDRONS, THIS IS NO LONGER THE CASE. WE READ THE
C          BOUNDARY CONNECTIVITY TABLE BEFORE INITIALISING THE NUMBER OF
C          BOUNDARY NODES AND ELEMENTS. THIS IS WELL DEFINED NOW.
!
C IN 2D IT IS CALL ALLVEC(2, MESH%NULONE, 'NULONE', 0,  2, 1)
C WHICH, IN 2D ONLY IS EQUIVALENT TO
C             CALL ALLVEC(2, MESH%NULONE, 'NULONE', 1,  2, 1)
C IN 3D IT IS CALL ALLVEC(2, MESH%NULONE, 'NULONE', 20, 4, 1)
!
!
C     KP1BOR
C
      ALLOCATE(MESH%KP1BOR)
      CALL ALLVEC(2,MESH%KP1BOR,'KP1BOR', IELBOR(IELM,1),2,1)
C
C     NBOR: GLOBAL NUMBERS OF THE BOUNDARY NODES
C     ALLOCATES NBOR, IT WILL BE READ IN LECLIM
C
      ALLOCATE(MESH%NBOR)
      CALL ALLVEC(2, MESH%NBOR,'NBOR  ', IELBOR(IELM,2) , 1, 1)
!
C     IKLBOR: IKLE FOR THE SEGMENTS OR BOUNDARY SIDES
!
!
C IN ALME3D:
C IN 2D: CALL ALLVEC(2, MESH%IKLBOR,'IKLBOR',  1, 2, 1) ! WHY 1, 2?
C IN 3D: CALL ALLVEC(2, MESH%IKLBOR,'IKLBOR', 20, 4, 1) ! PROPER
C USAGE IKLBOR(NPTFR,NETAGE,4)
!
      ALLOCATE(MESH%IKLBOR)
!
      IF(IELM.EQ.41.OR.IELM.EQ.51) THEN
C       LATERAL BOUNDARY SIDES
C       SEE ININDS FOR ELEMENTS 20 AND 21
        CALL ALLVEC(2,MESH%IKLBOR,'IKLBOR',
     &              IELBOR(IELM0,2),NBPEL(IELBOR(IELM1,2)),1)
      ELSEIF(IELM.EQ.11.OR.IELM.EQ.12.OR.IELM.EQ.13
     &   .OR.IELM.EQ.31) THEN
        CALL ALLVEC(2,MESH%IKLBOR,'IKLBOR',
     &              IELBOR(IELM0,1),NBPEL(IELBOR(IELM ,2)),1)
      ELSE
        WRITE(LU,*) 'ALMESH : UNKNOWN ELEMENT FOR IKLBOR:',IELM
        CALL PLANTE(1)
        STOP
      ENDIF
C
C     IFANUM: NUMBER OF THE SIDE IN ADJACENT ELEMENT
C
      ALLOCATE(MESH%IFANUM)
      IF(CFG(1).EQ.2) THEN
        CALL ALLVEC(2,MESH%IFANUM,'IFANUM',
     &              3*NBMPTS(IELM0)+NBMPTS(01) ,1,0 )
      ELSEIF(CFG(1).NE.1.AND.CFG(1).NE.3) THEN
        IF(LNG.EQ.1) WRITE(LU,98) CFG(1)
        IF(LNG.EQ.2) WRITE(LU,99) CFG(1)
98      FORMAT(1X,'ALMESH : STOCKAGE INCONNU :',1I6)
99      FORMAT(1X,'ALMESH : UNKNOWN STORAGE:',1I6)
        CALL PLANTE(1)
        STOP
      ELSE
        CALL ALLVEC(2,MESH%IFANUM,'IFANUM', 0 , 1,0 )
      ENDIF
C
C     IKLEM1: INVERSE CONNECTIVITY TABLE FOR FRONTAL PRODUCT
C     LIMVOI: LIMITING NUMBER OF A GIVEN NUMBER OF NEIGHBOURS
C
      ALLOCATE(MESH%IKLEM1)
      ALLOCATE(MESH%LIMVOI)
      IF(CFG(2).EQ.2) THEN
C       CALL ALLVEC(2,MESH%IKLEM1,'IKLEM1',NBMPTS(IELM1)*MXPTVS,4,0)
C       FOR OPTASS=3: SYM AND NOT SYM ARE DIFFERENT
        CALL ALLVEC(2,MESH%IKLEM1,'IKLEM1',NBMPTS(IELM1)*MXPTVS,8,0)
        CALL ALLVEC(2,MESH%LIMVOI,'LIMVOI',MXPTVS,2,0)
      ELSEIF(CFG(2).NE.1) THEN
        IF(LNG.EQ.1) WRITE(LU,96) CFG(2)
        IF(LNG.EQ.2) WRITE(LU,97) CFG(2)
96      FORMAT(1X,'ALMESH : PRODUIT MATRICE-VECTEUR INCONNU :',1I6)
97      FORMAT(1X,'ALMESH: UNKNOWN MATRIX-VECTOR PRODUCT:',1I6)
        STOP
      ELSE
        CALL ALLVEC(2,MESH%IKLEM1,'IKLEM1',0,4,0)
        CALL ALLVEC(2,MESH%LIMVOI,'LIMVOI',0,2,0)
      ENDIF
C
C     INTEGER ARRAYS FOR SEGMENT-BASED STORAGE
C
      ALLOCATE(MESH%GLOSEG)
      ALLOCATE(MESH%ELTSEG)
      ALLOCATE(MESH%ORISEG)
C     FROM 5.9 ON, ALWAYS DONE IN 2D (IELM=11,12,13 OR 14)
C     FROM 6.0 ON, ALWAYS DONE
C     IF(CFG(1).EQ.3.OR.10*(IELM/10).EQ.10) THEN
        CALL ALLVEC(2,MESH%GLOSEG,'GLOSEG',NBSEG(IELM)  ,2,0)
        CALL ALLVEC(2,MESH%ELTSEG,'ELTSEG',NBMPTS(IELM0),
     &                                     NBSEGEL(IELM),0)
        CALL ALLVEC(2,MESH%ORISEG,'ORISEG',NBMPTS(IELM0),
     &                                     NBSEGEL(IELM),0)
C     ELSE
C       CALL ALLVEC(2,MESH%GLOSEG,'GLOSEG',0,2,0)
C       CALL ALLVEC(2,MESH%ELTSEG,'ELTSEG',0,3,0)
C       CALL ALLVEC(2,MESH%ORISEG,'ORISEG',0,3,0)
C     ENDIF
C
C     INTEGER ARRAYS FOR PARALLEL MODE
C
C     KNOLG
C     NACHB
C     ISEG
C     KNOGL
C     INDPU
C     NHP
C     NHM
C
      ALLOCATE(MESH%KNOLG)
      ALLOCATE(MESH%NACHB)
      ALLOCATE(MESH%ISEG)
      ALLOCATE(MESH%KNOGL)
      ALLOCATE(MESH%INDPU)
      ALLOCATE(MESH%NHP)
      ALLOCATE(MESH%NHM)
      ALLOCATE(MESH%IFAPAR)
      ALLOCATE(MESH%NB_NEIGHB)
      ALLOCATE(MESH%NB_NEIGHB_SEG)
C     THERE ALLVEC IS IN PARINI
      ALLOCATE(MESH%NB_NEIGHB_PT)
      ALLOCATE(MESH%LIST_SEND)
      ALLOCATE(MESH%NH_COM)
      ALLOCATE(MESH%NB_NEIGHB_PT_SEG)
      ALLOCATE(MESH%LIST_SEND_SEG)
      ALLOCATE(MESH%NH_COM_SEG)
C
      IF(NCSIZE.GT.1) THEN
C
        CALL ALLVEC(2,MESH%KNOLG,'KNOLG ',IELM1            ,1,1)
        CALL ALLVEC(2,MESH%NACHB,'NACHB ',NBMAXNSHARE*NPTIR,1,0)
        CALL ALLVEC(2,MESH%ISEG ,'ISEG  ',IELBOR(IELM1,1)  ,1,1)
C FH-JAJ
C FOR THE SIZE OF KNOGL, WE NEED THE NUMBER OF NODES
C WE CAN'T HAVE THIS VALUE, THEN WE TAKE THE SUM OF THE NODES
C OF EACH SUB-MESH (VALUE BIGGER THAN THE NUMBER OF NODES IN THE MESH)
C THE SIZE OF KNOGL IS THUS EVER BIGGER THAN THE NUMBER OF NODES IN THE MESH
        NPOIN_MAX = P_ISUM(MESH%NPOIN)
        CALL ALLVEC(2,MESH%KNOGL,'KNOGL ',NPOIN_MAX,1,0)
C FH-JAJ
        CALL ALLVEC(2,MESH%INDPU,'INDPU ',IELM1              ,1,1)
        CALL ALLVEC(2,MESH%NHP  ,'NHP   ',NBMAXDSHARE*2*NPTIR,1,0)
        CALL ALLVEC(2,MESH%NHM  ,'NHM   ',NBMAXDSHARE*2*NPTIR,1,0)
        CALL ALLVEC(2,MESH%IFAPAR,'IFAPAR',10,6,1)
        DO I=1,6*NBPTS(10)
          MESH%IFAPAR%I(I)=0
        ENDDO
C
      ELSE
C
        CALL ALLVEC(2,MESH%KNOLG ,'KNOLG ',0,1,0)
        CALL ALLVEC(2,MESH%NACHB ,'NACHB ',0,1,0)
        CALL ALLVEC(2,MESH%ISEG  ,'ISEG  ',0,1,0)
        CALL ALLVEC(2,MESH%KNOGL ,'KNOGL ',0,1,0)
        CALL ALLVEC(2,MESH%INDPU ,'INDPU ',0,1,0)
        CALL ALLVEC(2,MESH%NHP   ,'NHP   ',0,1,0)
        CALL ALLVEC(2,MESH%NHM   ,'NHM   ',0,1,0)
        CALL ALLVEC(2,MESH%IFAPAR,'IFAPAR',0,1,0)
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C  FINITE VOLUMES
C
      ALLOCATE(MESH%NUBO)
      IF(EQUA(1:15).EQ.'SAINT-VENANT VF') THEN
        CALL ALLVEC(2,MESH%NUBO,'NUBO  ',2*NSEG,1,0)
      ELSE
        CALL ALLVEC(2,MESH%NUBO,'NUBO  ',     0,1,0)
      ENDIF
C
      ALLOCATE(MESH%JMI)
      IF(EQUA(1:15).EQ.'SAINT-VENANT VF') THEN
        CALL ALLVEC(2,MESH%JMI,'JMI   ',NSEG,1,0)
      ELSE
        CALL ALLVEC(2,MESH%JMI,'JMI   ',   0,1,0)
      ENDIF
C
C-----------------------------------------------------------------------
C
C     FILLS ARRAYS IKLE, X AND Y (AND Z)
C
C     PRISMS CUT INTO TETRAHEDRONS
C
      IF(IELM.EQ.51) THEN
C
        CALL CPIKLE3(MESH%IKLE%I,IKLES,NELEM,NNELMAX,NPOIN,NNPLAN)
C
C       NOTE : NO Z HERE, AS IELM.EQ.41, SEE NOTE BELOW
        CALL READGEO3(MESH%KNOLG%I,MESH%X%R,MESH%Y%R,NPOIN,NFIC,IB)
C
C     PRISMS
C
      ELSEIF(IELM.EQ.41) THEN
C
        CALL CPIKLE2(MESH%IKLE%I,MESH%KLEI%I,IKLES,
     &               NELEM,NNELMAX,NPOIN,NNPLAN)
C       NOTE : WITH PRISMS Z IS COMPUTED WITH ZF AND H, OR
C              READ IN THE PREVIOUS COMPUTATION FILE, HENCE NO Z HERE
        CALL READGEO3(MESH%KNOLG%I,MESH%X%R,MESH%Y%R,NPOIN,NFIC,IB)
C
C     TRIANGLES OR TETRAHEDRONS
C
      ELSEIF(IELM.EQ.11.OR.IELM.EQ.12.OR.IELM.EQ.13.OR.IELM.EQ.14
     &   .OR.IELM.EQ.31) THEN
C
C       IKLES(NDP,NELEM) COPIED INTO IKLE(NELMAX,NDP) AND KLEI(NDP,NELMAX)
        DO I = 1,NDP
          DO IELEM  = 1,NELEM
            MESH%IKLE%I((I-1)*NNELMAX+IELEM) = IKLES((IELEM-1)*NDP+I)
            MESH%KLEI%I((IELEM-1)*NDP+I)     = IKLES((IELEM-1)*NDP+I)
          ENDDO
        ENDDO
        IF(IELM.EQ.11.OR.IELM.EQ.12.OR.IELM.EQ.13.OR.IELM.EQ.14) THEN
          CALL READGEO3(MESH%KNOLG%I,MESH%X%R,MESH%Y%R,NPOIN,NFIC,IB)
        ELSEIF(IELM.EQ.31) THEN
C         TETRAHEDRONS: READS THE Z COORDINATE AFTER X AND Y
          CALL READGEO3(MESH%KNOLG%I,MESH%X%R,MESH%Y%R,NPOIN,NFIC,IB,
     &                  MESH%Z%R)
        ENDIF
C
      ELSE
C
C OTHER ELEMENT TYPES
C
        WRITE(LU,*) 'ALMESH : UNKNOWN ELEMENT:',IELM
        CALL PLANTE(1)
        STOP
C
      ENDIF
C
C     COMPLEMENTS ARRAYS X, Y FOR PRISMS AND TETRAHEDRONS
C
      IF(IELM.EQ.41.OR.IELM.EQ.51) THEN
        DO I = 2,NNPLAN
          CALL OV_2( 'X=Y     ' , MESH%X%R,I, MESH%X%R,1,
     &                            MESH%X%R,1, 0.D0, NNPMAX,NPOIN)
          CALL OV_2( 'X=Y     ' , MESH%Y%R,I, MESH%Y%R,1,
     &                            MESH%Y%R,1, 0.D0, NNPMAX,NPOIN)
        END DO
      ENDIF
!
C  WATCH OUT - D Y N A M I T E
!
C FOR 3D MATRICES COMPUTATION, X,Y,Z (PER NODE) ARE USED INSTEAD
C OF XEL,YEL,ZEL (PER ELEMENT)...  -- REQUIRES A THOROUGH CHECKING
C OF BIEF5, WHERE XEL,YEL,ZEL ARE USED IN CALLS FOR 3D CASES
C I SET SIMPLY:
C                      TEMPORARY
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CC START 3D MESH
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IF(IELM.EQ.31.OR.IELM.EQ.41.OR.IELM.EQ.51) THEN
        MESH%XEL => MESH%X
        MESH%YEL => MESH%Y
        MESH%ZEL => MESH%Z
      ENDIF
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CC END 3D MESH
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
C
C-----------------------------------------------------------------------
C
C DEALLOCATES TEMPORARY ARRAYS
C
      DEALLOCATE(IKLES)

C-----------------------------------------------------------------------
C
      IF(LNG.EQ.1) WRITE(LU,*) 'MAILLAGE : ',NOM,' ALLOUE'
      IF(LNG.EQ.2) WRITE(LU,*) 'MESH: ',NOM,' ALLOCATED'
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C#######################################################################
C