!                   *********************
                    PROGRAM PARTEL_PRELIM
!                   *********************
!
!***********************************************************************
! PARALLEL   V6P2                                   20/02/2012
!***********************************************************************
!
!BRIEF    PREPROCESSING STEP BEFORE A PARALLEL COMPUTATION
!HISTORY   R. KOPMANN (BAW)
!+
!+
!+         FIRST  VERSION JANUARY-MARCH 2000
!
!HISTORY   JAJ
!+      12/12/2000
!+      SECOND VERSION PINXIT
!+     PARTITIONING OF GEOMETRY AND 2D RESULT FILES POSSIBLE

!HISTORY   JAJ
!+      22/02/2002
!+      THIRD VERSION
!+     ERRORS IN BC VALUES IN DECOMPOSED BC FILES REMOVED
!+     ERRONEOUS TREATMENT OF ISLANDS DEBUGGED
!
!HISTORY   J-M HERVOUET ; JAJ
!+      17/04/2002
!+     FOURTH VERSION
!+     PARTITIONING FOR 3D RESULT FILES DONE BY JMH
!+     INCLUDING BOTH PARTITIONING METHODS AND BEAUTIFYING BY JAJ
!
!HISTORY  J-M HERVOUET
!+     21/01/2003
!+     FIFTH VERSION
!+     CORRECTED A WRONG DIMENSION OF THE ARRAY CUT, AN ERROR
!+     OCCURING BY A LARGER NUMBER OF PROCESSORS
!
!HISTORY  JAJ; MATTHIEU GONZALES DE LINARES
!+        27/01/2003
!+        SIXTH VERSION
!+    CORRECTED A WRONG DIMENSION OF THE ARRAY ALLVAR
!
!HISTORY  J-M HERVOUET
!+       12/03/2003
!+      SEVENTH VERSION
!+      ALGORITHM CHANGED : A SEGMENT IS IN A SUBDOMAIN IF IT BELONGS
!+      TO AN ELEMENT IN THE SUBDOMAIN NOT IF THE 2 POINTS OF THE
!+      SEGMENT BELONG TO THE SUBDOMAIN.
!+       SPECIFIC ELEBD INCLUDED, ALL REFERENCE TO MPI OR BIEF REMOVED
!
!HISTORY  J-M HERVOUET
!+        01/09/2003
!+      EIGHTH VERSION
!+      UBOR AND VBOR INVERTED LINE 613 WHEN READING THE CLI FILE.
!
!HISTORY   C. MOULINEC, P. VEZOLLE, O. BOITEAU
!+
!+      NEXT VERSION
!+      SOME CHANGES
!
!HISTORY   C. DENIS (EDF-SINETICS)
!+        31/05/2010
!+      V6P2
!+      FURTHER DEVELOPPED IN ORDER TO DECREASE THE AMOOUT OF MEMORY
!
!HISTORY  N.DURAND (HRW), S.E.BOURBAN (HRW)
!+        21/02/2012
!+        V6P2
!+   CREATION OF DOXYGEN TAGS FOR AUTOMATED DOCUMENTATION AND
!+   CROSS-REFERENCING OF THE FORTRAN SOURCES
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
      IMPLICIT NONE
!
!   MAXIMUM GEOMETRICAL MULTIPLICITY OF A NODE (VARIABLE AUSSI
!   PRESENTE DANS LA BIEF, NE PAS CHANGER L'UNE SANS L'AUTRE)
      INTEGER, PARAMETER :: NBMAXNSHARE =  10
!     
      INTEGER, PARAMETER :: MAXNPROC = 100000 ! MAX PARTITION NUMBER [00000..99999]
      INTEGER, PARAMETER :: MAXLENSOFT = 144 ! SOFT MAX FILE NAME LENGTH
      INTEGER, PARAMETER :: MAXLENHARD = 250 ! HARD MAX FILE NAME LENGTH
      INTEGER, PARAMETER :: MAXADDCH = 10 ! MAX ADDED SUFFIX LENGTH
      INTEGER, PARAMETER :: MAXVAR = 100  ! MAX NUMBER OF VARIABLES
      INTEGER, PARAMETER :: MAXALLVARLENGTH = 3200 ! MAXVAR*32 FOR ALLVAR
!
      INTEGER PMETHOD
      INTEGER NVAR, NREC, NPLAN, NPTFR, NPTIR, NPTFRMAX
      INTEGER NELEM, NPOIN, NDP, NELEM2, NPOIN2, NDUM
      INTEGER FILE_MPI
      INTEGER IB(10)
!
      INTEGER, ALLOCATABLE :: IKLES(:), IKLES_P(:)
      INTEGER, ALLOCATABLE :: IKLES3D(:),IKLES3D_P(:,:,:)
      INTEGER, ALLOCATABLE :: IRAND(:), IRAND_P(:)
      INTEGER, ALLOCATABLE :: LIHBOR(:), LIUBOR(:), LIVBOR(:)
      INTEGER, ALLOCATABLE :: LITBOR(:)
      INTEGER ::  NPOIN_P, NELEM_P , NPTFR_P,NPTIR_P
      INTEGER, ALLOCATABLE :: NBOR(:), NBOR_P(:)
      INTEGER, ALLOCATABLE :: NUMLIQ(:), NUMSOL(:)
      INTEGER, ALLOCATABLE :: KNOLG(:), KNOGL(:),CHECK(:)
      INTEGER, ALLOCATABLE :: ELELG(:), ELEGL(:)
      INTEGER, ALLOCATABLE :: CUT(:), CUT_P(:), SORT(:)
      INTEGER, ALLOCATABLE :: PART_P(:,:), PART(:),PART_P1(:,:)
!
      REAL, ALLOCATABLE    :: F(:,:), F_P(:,:)
      REAL, ALLOCATABLE    :: HBOR(:) 
      REAL, ALLOCATABLE    :: UBOR(:), VBOR(:), AUBOR(:)
      REAL, ALLOCATABLE    :: TBOR(:), ATBOR(:), BTBOR(:)
!
      REAL TIMES, TIMED
!
      INTEGER :: NINP=10, NCLI=11, NMET=12,NINPFORMAT=52
      INTEGER :: NEPART=15, NNPART=16, NOUT=17, NCLM=18
      INTEGER TIME(3), DATE(3)
!
      CHARACTER(LEN=80)  :: TITLE
      CHARACTER(LEN=32)  :: VARI, VARIABLE(MAXVAR)
      CHARACTER(LEN=MAXALLVARLENGTH) :: ALLVAR 
      CHARACTER(LEN=MAXLENHARD)  :: NAMEINP, NAMECLI, NAMEOUT, NAMECLM,
     &     NAMECLMP,NAMEOUTP
      CHARACTER(LEN=MAXLENHARD)  :: NAMEMET,NAMEEPART,NAMENPART,
     &     NAMENINPFORMAT,NAMEOUTFORMA
      CHARACTER(LEN=5)   :: CHCH  
      CHARACTER(LEN=12)  :: FMT4
!
      INTEGER MAX_NELEM_P, MIN_NELEM_P
      INTEGER  MAX_NPOIN_P,MAX_N_NEIGH
      INTEGER I, J, K, L , M, N, P, ERR, ISO, IDUM
      INTEGER ISTOP, ISTART, ISEG, II, ILOOP
      INTEGER I_LEN, I_S, I_SP, I_LENCLI, I_LENINP
      INTEGER IELEM_P, IPOIN_P, IPTFR_P
!
      REAL XSEG, YSEG, BAL, RDUM
      DOUBLE PRECISION AREA, X1, X2, X3, Y1, Y2, Y3
      LOGICAL IS, WRT, TIMECOUNT
!
!   METISOLOGY
!
      INTEGER NPARTS, ETYPE, NUMFLAG, EDGECUT
      INTEGER, ALLOCATABLE :: EPART(:), NPART(:)
      CHARACTER(LEN=10) FMT1, FMT2, FMT3
!
!   FOR CALLING FRONT2
!
      INTEGER, PARAMETER :: MAXFRO = 3000  ! MAX NUMBER OF BOUNDARIES
      INTEGER NFRLIQ, NFRSOL, DEBLIQ(MAXFRO), FINLIQ(MAXFRO)
      INTEGER DEBSOL(MAXFRO), FINSOL(MAXFRO)
      INTEGER, ALLOCATABLE :: DEJAVU(:), KP1BOR(:,:)

!
!   FOR CALLING BIEF MESH SUBROUTINES (TO BE OPTIMISED SOON):
      INTEGER, ALLOCATABLE :: IFABOR(:,:), IFANUM(:,:), NELBOR(:)
      INTEGER, ALLOCATABLE :: NULONE(:,:)
      INTEGER, ALLOCATABLE :: IKLE(:,:), IKLBOR(:,:), ISEGF(:)
      INTEGER, ALLOCATABLE :: IT1(:), IT2(:), IT3(:)
!
      INTEGER LNG,LU,LI
      COMMON /INFO/ LNG,LU
!
!   TIME MEASURING 
!
      INTEGER  TDEB, TFIN, TDEBP, TFINP, TEMPS, PARSEC
      INTEGER  TDEB_GLOB, TFIN_GLOB
!
!   EXTENS FUNCTION
!   FD : EXTENS IS NOT USED IN THIS CONTEXT
!      CHARACTER(LEN=11) :: EXTENS
!      EXTERNAL EXTENS   
!
!----------------------------------------------------------------------
!
!   JAJ NEW FOR PARALLEL CHARACTERISTICS ////
!   HALO ELEMENTS: THESE ADJACENT TO THE INTERFACE EDGES HAVING 
!   NEIGHBOURS BEHIND A BOUNDARY 
!
      ! THE ELEMENTAL GLOBAL->LOCAL NUMBERING TRANSLATION TABLE 
      ! THIS IS ELEGL SAVED FROM ALL PARTITIONS FOR FURTHER USE
      DOUBLE PRECISION :: STARTTIME,ENDTIME,STARTIOTIME,STARTCTIME
      INTEGER, ALLOCATABLE :: GELEGL(:),GELEGL1(:)
!
      ! THE HALO ELEMENTS NEIGHBOURHOOD DESCRIPTION FOR A HALO CELL 
      INTEGER, ALLOCATABLE :: IFAPAR(:,:)
!
      ! THE NUMBER OF HALO CELLS PRO PARTITION 
      INTEGER :: NHALO 
!
      ! WORK VARIABLES 
      INTEGER IFALOC(3)
      INTEGER TEMP_I(8)
      DOUBLE PRECISION TEMP_F(9)
      LOGICAL FOUND
      INTEGER NDP_2D,NDP_3D,NB_INTER_GLOB,COMPT
      INTEGER EF,POS
      INTEGER, ALLOCATABLE :: NBRE_EF(:),NBRE_EF_LOC(:),EF_I(:),
     &     TAB_TMP(:),EF_II(:),GLOBAL_INTER_NODE_REORD(:)
      INTEGER, ALLOCATABLE :: PART_P_TMP1(:),PART_P_TMP2(:)
      LOGICAL TROUVE,HALO
      INTEGER NOEUD,NBRE_NOEUD_INTERNE
      INTEGER NBRE_NOEUD_INTERF
      INTEGER FRONTIERE, NBRE_EF_I,IER,ID,NBRE_NPTIR
      LOGICAL INTERFACE  
      CHARACTER (LEN=5) :: III
!   FOR SCOTCH 
   
!      DOUBLEPRECISION    GRAPH  (SCOTCH_GRAPHDIM)
!      DOUBLEPRECISION    STRADAT (SCOTCH_STRATDIM)
      INTEGER BASEVAL
      INTEGER VERTNBR
      INTEGER EDGENBR
      INTEGER, ALLOCATABLE :: VER (:)
      INTEGER, ALLOCATABLE :: EDGETAB (:)
!     
      NDP_2D=3
      NDP_3D=6
!    
!----------------------------------------------------------------------
!
      CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
      TIMECOUNT = .TRUE.
      IF (PARSEC==0) TIMECOUNT = .FALSE.  ! COUNT_RATE == 0 : NO CLOCK
      IF (TIMECOUNT) TDEB = TEMPS
!
      LNG=2 ! JE NE PARLE FRANCAIS, JE SUIS BARBARIEN
      LU=6  ! FORTRAN STANDARD OUPUT CHANNEL
      LI=5  ! FORTRAN STANDARD INPUT CHANNEL
!
! INTRODUCE YOURSELF
!
!      IF (ID .EQ. 0) THEN 
!       WRITE(LU,*) ' '
!       WRITE(LU,*) '+-------------------------------------------------+'
!       WRITE(LU,*) '  PRELIMINARY TASK FOR PARTEL                    '
!       WRITE(LU,*) '  PARALLEL VERSION DEVELOPPED BY                   '          
!       WRITE(LU,*) '  CHRISTOPHE DENIS  (SINETICS)'
!       WRITE(LU,*) '  PARTEL (C) COPYRIGHT 2000-2002 '
!       WRITE(LU,*) '  BUNDESANSTALT FUER WASSERBAU, KARLSRUHE'
!       WRITE(LU,*) ' '
!       WRITE(LU,*) '  METIS 4.0.1 (C) COPYRIGHT 1998 '
!       WRITE(LU,*) '  REGENTS OF THE UNIVERSITY OF MINNESOTA '
!       WRITE(LU,*) ' '
!       WRITE(LU,*) '  BIEF 5.9 (C) COPYRIGHT 2010 EDF'
!       WRITE(LU,*) '+-------------------------------------------------+'
!       WRITE(LU,*) '    LUN MAI 31 17:21:20 CEST 2010               ' 
!       WRITE(LU,*) ' '
!       WRITE(LU,*) '+-----------------------------------------------+'
!      END IF
!     
!----------------------------------------------------------------------
! NAMES OF THE INPUT FILES:
!      INQUIRE (FILE='PARTEL.PAR',EXIST=IS)
!      IF (.NOT.IS) THEN 
!        WRITE (LU,'('' FILE DOES NOT EXIST: '',A30)') 
!        CALL PLANTE2(-1)
!        STOP
!      END IF  
!###> SEB@HRW: SO YOU DO THIS ONLY ONCE
      INQUIRE (FILE='RESULT_SEQ_METIS',EXIST=IS)
      IF (IS) THEN 
        CALL PARTEL_PRELIM_PLANTE2(0)
        STOP
      END IF  
!###< SEB@HRW
!
!###> SEB@HRW: EASIER TO DO WITH ONE FILE ONLY
!      OPEN(UNIT=74,FILE='PARTEL_PRELIM.PAR')
      OPEN(UNIT=72,FILE='PARTEL.PAR')
      READ(72,*) NAMEINP
      READ(72,*) 
      READ(72,*) NPARTS
      READ(72,*) 
      CLOSE(72)
!###< SEB@HRW
!
      INQUIRE (FILE=NAMEINP,EXIST=IS)
      IF (.NOT.IS) THEN 
         WRITE (LU,'('' FILE DOES NOT EXIST: '',A30)') NAMEINP
         CALL PARTEL_PRELIM_PLANTE2(-1)
         STOP
      END IF
!
      PMETHOD=1
!
      I_S  = LEN(NAMEINP)
      I_SP = I_S + 1
      DO I=1,I_S
         IF (NAMEINP(I_SP-I:I_SP-I) .NE. ' ') EXIT
      ENDDO
      I_LEN=I_SP - I
      I_LENINP = I_LEN
!
      IF (I_LENINP > MAXLENSOFT) THEN
         WRITE(LU,*) ' '
         WRITE(LU,*) 'ATTENTION:'
         WRITE(LU,*) 'THE NAME OF THE INPUT FILE:'
         WRITE(LU,*) NAMEINP
         WRITE(LU,*) 'IS LONGER THAN ',MAXLENSOFT,' CHARACTERS' 
         WRITE(LU,*) 'WHICH IS THE LONGEST APPLICABLE NAME FOR TELEMAC '
         WRITE(LU,*) 'INPUT AND OUTPUT FILES. STOPPED. '
         CALL PARTEL_PRELIM_PLANTE2(-1)
         STOP
      ENDIF
!
      OPEN(NINP,FILE=NAMEINP,STATUS='OLD',FORM='UNFORMATTED')
      REWIND NINP
!
      READ (NINP) TITLE
      READ (NINP) I, J
      NVAR = I + J 
      ALLVAR(1:41) = 'X-COORDINATE----M---,Y-COORDINATE----M---'
      ISTART = 42
      DO I=1,NVAR
         READ(NINP) VARI
         VARIABLE(I) = VARI
         DO J=1,32
            IF(VARI(J:J).EQ.' ') VARI(J:J) = '-'
         END DO
         ISTOP = ISTART+20
         IF (ISTOP.GT.MAXALLVARLENGTH) THEN
            WRITE(LU,*) 'VARIABLE NAMES TOO LONG FOR STRING ALLVAR'
            WRITE(LU,*) 'STOPPED.'
            CALL PARTEL_PRELIM_PLANTE2(-1)
            STOP
         ENDIF
         ALLVAR(ISTART:ISTART) = ','
         ALLVAR(ISTART+1:ISTOP) = VARI
         ISTART=ISTOP+1
      ENDDO
!
!  READ THE REST OF THE SELAFIN FILE
!  10 INTEGERS, THE FIRST IS THE NUMBER OF RECORDS (TIMESTEPS)
!
      READ (NINP) (IB(I), I=1,10)
      IF (IB(8).NE.0.OR.IB(9).NE.0) THEN
         WRITE(LU,*) 'THIS IS A PARTIAL OUTPUT FILE'
         WRITE(LU,*) 'MAYBE MEET GRETEL BEFORE...'
      ENDIF 
      NREC  = IB(1)
      NPLAN = IB(7)
!
      IF (IB(10).EQ.1) THEN
         READ(NINP) DATE(1), DATE(2), DATE(3), TIME(1), TIME(2), TIME(3)
      ENDIF 
!
      READ (NINP) NELEM,NPOIN,NDP,NDUM
      IF (NPLAN.GT.1) THEN
         NPOIN2 = NPOIN/NPLAN
         NELEM2 = NELEM/(NPLAN-1)
         IF (MOD(NPOIN,NPLAN).NE.0) THEN 
            WRITE (LU,*) 'BUT NPOIN2 /= NPOIN3/NPLAN!'
            CALL PARTEL_PRELIM_PLANTE2(-1)
            STOP   
         ENDIF
         IF (MOD(NELEM,(NPLAN-1)).NE.0) THEN 
            WRITE (LU,*) 'BUT NELEM2 /= NELEM3/NPLAN!'
            CALL PARTEL_PRELIM_PLANTE2(-1)
            STOP
         ENDIF
      ELSE
         NPOIN2 = NPOIN
         NELEM2 = NELEM
      ENDIF
!
      IF (NDP.EQ.3) THEN  
!         WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 2D SELAFIN'
      ELSEIF (NDP.EQ.6) THEN
!         WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 3D SELAFIN'
      ELSE   
!         WRITE(LU,*) 'THE ELEMENTS ARE NEITHER TRIANGLES NOR PRISMS!'
!         WRITE(LU,*) 'NDP = ',NDP
         CALL PARTEL_PRELIM_PLANTE2(-1)
         STOP
      ENDIF
!
! NOW LET US ALLOCATE 
!
      ALLOCATE (IKLES(NELEM2*3),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PRELIM_ALLOER (LU, 'IKLES')
      IF(NPLAN.GT.1) THEN
         ALLOCATE (IKLES3D(NELEM*NDP),STAT=ERR)
         IF (ERR.NE.0) CALL PARTEL_PRELIM_ALLOER (LU, 'IKLES3D')
      ENDIF 
      ALLOCATE (IRAND(NPOIN),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PRELIM_ALLOER (LU, 'IRAND')
!   NVAR+2 : FIRST TWO FUNCTIONS ARE X AND Y
!   NPOIN IS 3D HERE IN 3D
      ALLOCATE (F(NPOIN,NVAR+2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PRELIM_ALLOER (LU, 'IRAND')
!
! CONNECTIVITY TABLE:
!
      IF(NPLAN.EQ.0) THEN
         READ(NINP) ((IKLES((K-1)*NDP+J),J=1,NDP),K=1,NELEM)
      ELSE
         READ(NINP) ((IKLES3D((K-1)*NDP+J),J=1,NDP),K=1,NELEM)
         DO J=1,3
            DO K=1,NELEM2
               IKLES((K-1)*3+J)=IKLES3D((K-1)*6+J)
            ENDDO
         ENDDO
      ENDIF
!
      READ(NINP) (IRAND(J),J=1,NPOIN)
      READ(NINP) (F(J,1),J=1,NPOIN)
      READ(NINP) (F(J,2),J=1,NPOIN)
!
      ILOOP = 0
!      DO 
!
!  READ THE TIME STEP
!
      READ(NINP) TIMES
!      WRITE(NINPFORMAT,*) TIMES
      ILOOP = ILOOP + 1
!
      TIMED = TIMES/3600
!      WRITE(LU,*) 'TIMESTEP: ',TIMES,'S = ',TIMED,'H'
!
! READ THE TIME VARIABLES; NO 1 AND 2 ARE X,Y
!
      DO K=3,NVAR+2
!         WRITE(LU,*) 'NOW READING VARIABLE',K-2
         READ(NINP) (F(J,K), J=1,NPOIN)
!         WRITE(NINPFORMAT,*) (F(J,K), J=1,NPOIN)
!         WRITE(LU,*) 'READING VARIABLE',K-2,' SUCCESSFUL'
      END DO
!     END DO
!     STOP
 111  CLOSE (NINP)
!
      NUMFLAG = 1
!
      ETYPE = 1
!
      IF (TIMECOUNT) THEN 
         CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
         TDEBP = TEMPS
      ENDIF
      ALLOCATE (EPART(NELEM2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PRELIM_ALLOER (LU, 'EPART')
      ALLOCATE (NPART(NPOIN2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PRELIM_ALLOER (LU, 'NPART')
      !WRITE(*,*) NELEM2,NPOIN2,NPARTS
!
      CALL PARTITIONER(1, NELEM2, NPOIN, 3, NPARTS, IKLES, EPART, NPART)
!
      OPEN(UNIT=256,FILE='RESULT_SEQ_METIS')
      DO I=1,NELEM2
         WRITE(256,*) EPART(I)
      END DO 

      !WRITE(*,*) 'END OF THE PRELIMINARY PART OF PARTEL'
      CONTAINS


      SUBROUTINE PARTEL_PRELIM_ALLOER (N, CHFILE)
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: N
      CHARACTER*(*), INTENT(IN) :: CHFILE
      WRITE(N,*) 'ERROR BY ALLOCATION OF ',CHFILE
      CALL PARTEL_PRELIM_PLANTE2(-1)
      STOP
      END SUBROUTINE PARTEL_PRELIM_ALLOER
      
      SUBROUTINE PARTEL_PRELIM_ALLOER2(N,CHFILE)
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: N
      CHARACTER*(*), INTENT(IN) :: CHFILE
      WRITE(N,*)TRIM(CHFILE)
      CALL PARTEL_PRELIM_PLANTE2(-1)
      STOP
      END SUBROUTINE PARTEL_PRELIM_ALLOER2

      SUBROUTINE PARTEL_PRELIM_PLANTE2 (IVAL)
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
!
      INTEGER, INTENT(IN) :: IVAL
      INTEGER ICODE
!     STANDARD F90 :  STOP [n] WHERE N IS A STRING OF NOT MORE
!     THAN FIVE DIGITS OR IS A CHARACTER CONSTANT.
!     HOWEVER, CODE IS NOT ALWAYS SENT TO STDERR
!     (COMPILER DEPENDENT, NAG DOESN'T FOR INSTANCE)
!     ICODE MIGHT BE USED IN A POSSIBLE SYSTEM DEPENDENT EXIT PROCEDURE
!     EXAMPLE : STOP 1 ; STOP '    1'
      IF(IVAL.LT.0) THEN
        ICODE = 0      ! JUST ASSUMED FOR NON-ERROR STOP
      ELSEIF(IVAL.EQ.0.OR.IVAL.EQ.1) THEN
        ICODE = 2      ! EXIT IVAL 0 OR 1 INDICATING A "CONTROLLED" ERROR
        STOP 2
      ELSE
        ICODE = 1     ! SOMETHING ELSE? BUT AN ERROR!
        STOP 1
      ENDIF
      WRITE(LU,*) 'RETURNING EXIT CODE: ', ICODE
      STOP 0   !WHICH IS USUALLY EQUIVALENT TO CALL EXIT(0)

!     JMH 30/09/2011 WHAT IS THIS (NAG COMPILER DOES NOT KNOW)
!     CALL EXIT(ICODE)
      END SUBROUTINE PARTEL_PRELIM_PLANTE2
!
!                    **************
                     SUBROUTINE PARTITIONER
!                    **************
     &    (PMETHOD, NELEM, NPOIN, NDP, NPARTS, IKLES, EPART, NPART)
!
!
!***********************************************************************
! PARALLEL   V6P2                                   21/08/2010
!***********************************************************************
!
!brief    call to the partionning software
!
!history   R. KOPMANN (BAW)
!+
!+
!+         created
!
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!| PMETHOD        |<--| 1: FOR METIS 2: FOR SCOTCH
!| NELEM          |<--| THE NUMBER OF ELEMENTS
!| NDP            |<--| THE NUMBE OF POINT PER ELEMENT
!| NPARTS         |<--| NUMBER OF PARTITIONS
!| IKLES          |<--| CONNECTIVITY TABLE
!| EPART          |-->| PARTITION NUMBER OF AN ELEMENT
!| MYPART         |-->| PARTITION NUMBER OF A POINT
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
#if defined (HAVE_SCOTCH)
      USE ISO_C_BINDING
#endif
      IMPLICIT NONE
#if defined (HAVE_SCOTCH)
      include 'scotchf.h'
#endif
!     
      INTEGER, INTENT(IN)  :: PMETHOD
      INTEGER, INTENT(IN)  :: NELEM
      INTEGER, INTENT(IN)  :: NPOIN
      INTEGER, INTENT(IN)  :: NDP
      INTEGER, INTENT(IN)  :: IKLES(NELEM*NDP)
      INTEGER, INTENT(IN)  :: NPARTS
      INTEGER, INTENT(OUT) :: EPART(NELEM)
!TODO: Remove ??
      INTEGER, INTENT(OUT) :: NPART(NELEM)
!
!-----------------------------------------------------------------------
!
!
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
!
      INTEGER :: I,J,K,ERR
      INTEGER ETYPE, NUMFLAG, EDGECUT, NCOMMONNODES
      INTEGER, ALLOCATABLE :: EPTR(:), EIND(:)
      INTEGER, ALLOCATABLE :: NULLTABLE(:)
      CHARACTER(LEN=10) :: FMT1, FMT2, FMT3
      INTEGER, ALLOCATABLE :: RECVBUF(:)
!
! SCOTCH
!
#if defined (HAVE_SCOTCH)
      REAL*8, DIMENSION(SCOTCH_GRAPHDIM) :: SCOTCHGRAPH
      REAL*8, DIMENSION(SCOTCH_STRATDIM) :: SCOTCHSTRAT
      TYPE(C_PTR), POINTER :: PTXADJ(:), PTADJNCY(:)
#endif
      INTEGER, POINTER :: XADJ2(:), ADJNCY2(:)

      IF(PMETHOD.EQ.1) THEN 
        WRITE(LU,*) 'BEGIN PARTITIONING WITH METIS'
!       NEW METIS INTERFACE (>= VERSION 5) :
!       
!       EPTR, EIND: THESE ARRAYS SPECIFIES THE ELEMENTS
!       THAT ARE STORED LOCALLY AT EACH PROCESSOR. 
!       CF. DISCUSSION IN SECTION 4.3 (?)
!       
        ALLOCATE(EPTR(NELEM+1),STAT=ERR)
        IF(ERR.NE.0) THEN
          WRITE(lu,*) 'ERROR: Bad allocation of EPTR'
        ENDIF 
        ALLOCATE(EIND(NELEM*NDP),STAT=ERR)
        IF(ERR.NE.0) THEN
          WRITE(lu,*) 'ERROR: Bad allocation of EIND'
        ENDIF 
!       
!       CORRECTION JMH 04/07/2012 : BELOW NDP MUST BE 3
!       IT WOULD NOT WORK IN 3D WITH NDP=6
!       
        DO I=1,NELEM+1
          EPTR(I) = (I-1)*NDP + 1
        ENDDO
!       
        K=1
        DO I=1,NELEM
          DO J=1,NDP
            EIND(K) = IKLES((I-1)*NDP+J)
            K = K + 1
          ENDDO   
        ENDDO    
!       
!       END OF CORRECTION JMH 04/07/2012
!       
!       SWITCH TO C NUMBERING
        EIND = EIND -1
        EPTR = EPTR -1
!       
!       METIS REQUIRES THE NUMBER OF COMMON POINT NEEDED BETWEEN 2 ELEMENTS TO MAKE AN EDGE
!       NCOMMONNODES = 2   FOR TRIANGLE OR RECTANGLE
!       NCOMMONNODES = 3   FOR TETRAHEDRE
!       NCOMMONNODES = 4   FOR HEXAHEDRE
        
!       
        IF (NDP==3.OR.NDP==6) THEN 
           NCOMMONNODES = 2 ! FOR TRIANGLE OR PRISM
        ELSE IF(NDP==4) THEN
           NCOMMONNODES = 3 ! FORT TETRAHEDRON
        ELSE
           WRITE(LU,*) 'METIS: IMPLEMENTED FOR TRIANGLES OR PRISMS ONLY'
           CALL PARTEL_PRELIM_PLANTE2(-1)
        ENDIF 
!        
!       WE ONLY USE METIS_PARTMESHDUAL AS ONLY THE FINITE ELEMENTS PARTITION
!       IS RELEVANT HERE.
!       
!       IMPORTANT: WE USE FORTRAN-LIKE FIELD ELEMENTS NUMBERING 1...N
!       IN C VERSION, 0...N-1 NUMBERING IS APPLIED!!!
!       
        NUMFLAG = 1
!       
#if defined(HAVE_MPI)
        CALL METIS_PARTMESHDUAL 
     &        (NELEM, NPOIN, EPTR, EIND, NULLTABLE,
     &         NULLTABLE, NCOMMONNODES, NPARTS, NULLTABLE, 
     &         NULLTABLE, EDGECUT, EPART, NPART)
#else
        WRITE(LU,*) 'ERROR: TRY TO RUN PARTEL WITH A '//
     &              'SERIAL CONFIGURATION'
        CALL PARTEL_PRELIM_PLANTE2(-1)
#endif
!       
!       DEALLOCATING TEMPORARY ARRAYS FOR METIS
!       
!       EPART IS AN ARRAY
        EPART = EPART+1
        DEALLOCATE(EPTR)
        DEALLOCATE(EIND)
      ELSE IF(PMETHOD.EQ.2) THEN
#if defined (HAVE_SCOTCH)      
!
!       SCOTCH PARTITIONER
!      
        WRITE(LU,*) 'BEGIN PARTITIONING WITH SCOTCH'
        ALLOCATE (EPTR(NELEM+1),STAT=ERR)
        IF (ERR.NE.0) CALL PARTEL_PART_ALLOER (LU, 'EPTR')
        ALLOCATE (EIND(NELEM*NDP),STAT=ERR)
        IF (ERR.NE.0) CALL PARTEL_PART_ALLOER (LU, 'EIND')
!
!       bUILDING EPTR AND EIND SAME AS BEFORE.
!
        DO I=1,NELEM+1
           EPTR(I) = (I-1)*NDP + 1
        ENDDO
! 
        K=1
        DO I=1,NELEM
           DO J=1,NDP
              EIND(K) = IKLES((I-1)*NDP+J)
              K = K + 1
           ENDDO   
        ENDDO    
!       THE NUMBER OF COMMON POINT NEEDED BETWEEN 2 ELEMENTS TO MAKE AN
!       EDGE
!       NCOMMONNODES = 2 FOR TRIANGLE OR RECTANGLE
!       NCOMMONNODES = 3 FOR TETRAHEDRE
!       NCOMMONNODES = 4 FOR HEXAHEDRE
        IF (NDP==3.OR.NDP==6) THEN 
           NCOMMONNODES = 2 ! FOR TRIANGLE OR RECTANGLE
        ELSE
           WRITE(LU,*)'SCOTCH: IMPLEMENTED FOR TRIANGLES OR PRISMS ONLY'
           CALL PARTEL_PRELIM_PLANTE2(-1)
        ENDIF 

!
!       mETIS_MESHTODUAL USES POINTER OF POINTER (PTXADJ, PTADJNCY) SO IN ORDER TO USE THAT
!       IN FORTRAN WE USE THE ISO_BINDING MODULE
!        
        ALLOCATE(PTXADJ(1))
        ALLOCATE(PTADJNCY(1))
!
!       BUILD THE DUAL GRAPH BY CALLING THE METIS SUBROUTINE
!        
        NUMFLAG = 1
        CALL METIS_MESHTODUAL
     &       (NELEM, NPOIN, EPTR, EIND, NCOMMONNODES, NUMFLAG,
     &        PTXADJ, PTADJNCY)

!
!       TRANSFORM THE C POINTER OF POINTER BACK TO A FORTRAN ARRAY
!        
        ALLOCATE(RECVBUF(1))
        RECVBUF(1) = NELEM+1
        CALL C_F_POINTER(PTXADJ(1),XADJ2,RECVBUF)
!        
        RECVBUF(1) = XADJ2(NELEM+1)-1
        CALL C_F_POINTER(PTADJNCY(1),ADJNCY2,RECVBUF)
        DEALLOCATE(RECVBUF)
!
!       INITIALIZE THE GRAPH AND THE STRATEGY USED BY SCOTCH FOR THE
!       PARTITIONING WE USE THE DEFAULT STRATEGY
!        
        CALL SCOTCHFSTRATINIT(SCOTCHSTRAT, ERR)
        IF (ERR.NE.0) THEN
          WRITE(LU,*) 'SCOTCH ERROR: CANNOT INITIALIZE STRAT'
          CALL PARTEL_PRELIM_PLANTE2(-1)
        ENDIF
!
        CALL SCOTCHFGRAPHINIT(SCOTCHGRAPH, ERR)
        IF (ERR.NE.0) THEN
          WRITE(LU,*) 'SCOTCH ERROR: CANNOT INITIALIZE GRAPH'
          CALL PARTEL_PRELIM_PLANTE2(-1)
        ENDIF
!
        CALL SCOTCHFGRAPHBUILD ( SCOTCHGRAPH,         ! GRAFDAT
     &                           NUMFLAG,             ! BASEVAL
     &                           NELEM,              ! VERTNBR
     &                           XADJ2(1:NELEM),     ! VERTTAB
     &                           XADJ2(2:NELEM+1),   ! VENDTAB 
     &                           XADJ2(1:NELEM),     ! VELOTAB, VERTEX WEIGHTS (nULL)
     &                           XADJ2(1:NELEM),     ! VLBLTAB, VERTEX LABELS (nULL)
     &                           XADJ2(NELEM+1)-1,   ! EDGENBR 
     &                           ADJNCY2,             ! EDGETAB 
     &                           ADJNCY2,             ! EDLOTAB (nULL)
     &                           ERR )
!
        IF (ERR.NE.0) THEN
          WRITE(LU,*) 'SCOTCH ERROR: CANNOT BUILD GRAPH'
          CALL PARTEL_PRELIM_PLANTE2(-1)
        ENDIF
!
        CALL SCOTCHFGRAPHCHECK(SCOTCHGRAPH,ERR)
        IF (ERR.NE.0) THEN
          WRITE(LU,*) 'SCOTCH ERROR: GRAPH NOT CONSISTANT'
          CALL PARTEL_PRELIM_PLANTE2(-1)
        ENDIF
!
        ! RUN PARTITIONING
        CALL SCOTCHFGRAPHPART ( SCOTCHGRAPH, 
     &                          NPARTS, 
     &                          SCOTCHSTRAT,
     &                          EPART, 
     &                          ERR )
!
        IF (ERR.NE.0) THEN
          WRITE(LU,*) 'SCOTCH ERROR: CANNOT PARTITION GRAPH'
          CALL PARTEL_PRELIM_PLANTE2(-1)
        END IF
!!!! CHANGING EPART NUMBERING TO 1-NPART
        EPART = EPART + 1

        CALL SCOTCHFGRAPHEXIT (SCOTCHGRAPH)
        CALL SCOTCHFSTRATEXIT (SCOTCHSTRAT)

!
!        THOSE DEALLOCATION CAN GENERATE ERROR WITH SOME COMPILER
!        DEALLOCATE(XADJ2)
!        DEALLOCATE(ADJNCY2)
        DEALLOCATE(PTXADJ)
        DEALLOCATE(PTADJNCY)
        DEALLOCATE(EIND)
        DEALLOCATE(EPTR)
#else
        WRITE(LU,*) "TRYING TO USE SCOTCH TO PARTIONNE WHEN SCOTCH",
     &              " IS NOT INSTALLED"
        CALL PARTEL_PRELIM_PLANTE2(-1)
#endif        
        ENDIF
      END SUBROUTINE PARTITIONER
!
      END PROGRAM PARTEL_PRELIM
